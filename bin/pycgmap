#!/usr/bin/env python3

# Copyright 2020 University of Groningen
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Perform the parsing and input redirect for the
different subcommands. This is the main executable.
"""
import argparse
import pathlib
import numpy as np
import MDAnalysis as mda
from MDAnalysis import transformations
from MDAnalysis.coordinates.memory import MemoryReader
from MDAnalysis.analysis.base import AnalysisFromFunction
import vermouth
from vermouth.file_writer import open, DeferredFileWriter
import vermouth.forcefield
import pycgmap
import pycgmap.mapping
import pycgmap.calc_inter


VERSION = 'pycgmap version {}'.format(pycgmap.__version__)

def main():
    """
    Parses commandline arguments and perform transformation.
    """

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument('-V', '--version', action='version', version=VERSION)


    file_group = parser.add_argument_group('Input Files')
    file_group.add_argument('-f', dest='traj', required=False, type=str,
                            help='trajectory file (XTC/TRR/GRO/PDB ...)')
    file_group.add_argument('-s', dest='tpr', required=False, type=str,
                            help='GROMACS tpr file (TPR)')
    file_group.add_argument('-itp', dest='itp', required=False, type=str,
                            help='dummy itp file')
    file_group.add_argument('-o', dest='outpath', type=str,
                            help='output ITP (ITP)')
    file_group.add_argument('-n', dest='index', type=str,
                            help='index file (NDX)')
    file_group.add_argument('-map', dest='mappings', type=str,
                            help='mapping files')
    file_group.add_argument('-npdbs', dest='npdbs', type=str,
                            help='index file (NDX)', nargs='*')

    mapping_group = parser.add_argument_group('Mapping Options')
    mapping_group.add_argument('-map', dest='mode', required=False, type=str,
                               help='COG or COM mapping', default='COG')
    mapping_group.add_argument('-merge', dest='merge', required=False, action='store_true',
                               help='Find equivalent bonds/angles/dihedrals and merge them.')
    mapping_group.add_argument('-T', dest='temp', required=False, default=298.15,
                               help='temperature')
    mapping_group.add_argument('-method', dest='inter_mode', required=False, type=str,
                               help='', default='modf_boltz')
    args = parser.parse_args()

    print("INFO - Loading")
    # load trajectory
    if args.tpr and args.traj:
        init_universe = mda.Universe(args.tpr, args.traj)
    elif args.npdbs:
        init_universe = pycgmap.mapping.load_n_frames(args.npdbs)
    else:
        init_universe = mda.Universe(args.traj)

    # load itp file
    force_field = vermouth.forcefield.ForceField("CG_FF")
    with open(args.itp) as _file:
        lines = _file.readlines()

    vermouth.gmx.itp_read.read_itp(lines, force_field=force_field)
    molecule = list(force_field.blocks.values())[0].to_molecule()

    # generate an ordered (!) mapping dict
    mapping_dict = pycgmap.mapping.establish_mapping(init_universe,
                                                     ndx_file=args.index,
                                                     mapping=args.mappings)

    print("INFO - Preparing coordinates")
    # get one unique atomg group based on the mapping
    all_atoms = list(mapping_dict.values())[0]
    for atom_group in list(mapping_dict.values())[1:]:
        all_atoms = all_atoms.union(atom_group)

    # only load and write those atoms that we need
    universe = mda.Merge(all_atoms).load_new(AnalysisFromFunction(lambda ag: \
                                                                  ag.positions.copy(),
                                                                  all_atoms).run().results,
                                             format=MemoryReader)
    # copy the dimensions of the box as well
    dimensions = np.zeros((init_universe.trajectory.n_frames, 6), np.float32)
    for fdx, ts in enumerate(init_universe.trajectory):
        dimensions[fdx] = ts.dimensions

    universe.trajectory.dimensions_array = dimensions
    # we need to establish a new mapping between the original atom-groups
    # and the new one, note that the order depends on the sequence in unique_atoms
    for node, atomgroup in mapping_dict.items():
        new_atoms = []
        for atom in atomgroup:
            new_atoms.append(list(all_atoms).index(atom))
        select_string  = "index " + " ".join(map(str, new_atoms))
        new_atom_group = universe.select_atoms(select_string)
        mapping_dict[node] = new_atom_group

    # finally we need a larger atom-group again
    print("INFO - Making PBC whole")
    if not args.npdbs:
        universe.trajectory.add_transformations(transformations.unwrap(universe.atoms))

    # map the universe to cg_universe
    cg_universe = pycgmap.mapping.create_mda_universe_from_itp(molecule)
    # transform the aa trajectory to cg
    print("INFO - Mapping universe to CG")
    cg_universe = pycgmap.mapping.mapping_transformation(universe,
                                                         molecule,
                                                         cg_universe,
                                                         mapping_dict,
                                                         mode=args.mode)
    # write coordinate
  #  if args.traj:
    print("INFO - Writing CG trajectory")
    if args.traj:
        path = pathlib.Path(args.traj)
        file_extension = path.suffix.casefold()[1:]
    else:
        file_extension = "xtc"

    if file_extension in ["xtc", "trr"]:
        cg_beads = cg_universe.atoms
        with mda.Writer(args.outpath,
                        multiframe=True,
                        n_atoms=len(cg_universe.atoms)) as mapped:
            for time_step in cg_universe.trajectory:
                mapped.write(cg_beads)
    else:
        cg_universe.atoms.positions = cg_universe.trajectory.coordinate_array[0]
        cg_beads = cg_universe.atoms
        with mda.Writer(args.outpath,
                        n_atoms=len(cg_universe.atoms)) as mapped:
                mapped.write(cg_beads)

    # if redundant is ture find redudant interacitons
    #if args.merge:
    #   print("Cannot do this yet.")

    # compute bonds angles etc.
    print("INFO - Computing interactions")
    const = 8.314462*10**-3.0
    pycgmap.calc_inter.compute_interaction_parameters(cg_universe,
                                                      molecule,
                                                      mode=args.inter_mode,
                                                      temp=args.temp,
                                                      gas_const=const)
    # write itp-file
    with open("cg_out.itp", 'w') as outpath:
        vermouth.gmx.itp.write_molecule_itp(molecule, outpath,
                                            moltype=molecule.name,
                                            header=["pycgmap generated itp"])
    DeferredFileWriter().write()

if __name__ == '__main__':
    main()
