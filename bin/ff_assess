#!/usr/bin/env python3
"""
Main exe for scoring simulations against mapped trajectories
"""
import argparse
from glob import glob
import numpy as np
import MDAnalysis as mda
import vermouth.forcefield
import fast_forward
from fast_forward.interaction_distribution import interaction_distribution
from fast_forward.itp_to_ag import ITPInteractionMapper
from fast_forward.itp_parser_sub import read_itp
from fast_forward.interaction_plots import make_distribution_plot, make_matrix_plot, make_distances_distribution_plot
from fast_forward.score import hellinger, score_matrix, calc_score
from collections import defaultdict

VERSION = 'fast_forward version {}'.format(fast_forward.__version__)

def report_interactions(h_score_dict, score_dict, exclude_outliers=False):
    """
    Print out a report of the interaction.

    Parameters
    ----------
    score_dict : dict
        Dictionary with interaction types as keys and another dictionary as values.
    exclude_outliers : bool, optional
        Whether to exclude outliers (scores >= 0.5) from the overall score calculation, defaults to False
    """

    buff = ''

    buff += " [ Interaction Distribution Report ]\n"
    buff += f"   Overall Score : {{mean:.2f}} ± {{std:.2f}}\n\n"

    buff += " Interaction Scores:\n"
    buff += " 0 - identical, 1 - no overlap\n\n"

    buff += " Score guide:\n"
    buff += "   0.0-0.3 : good\n"
    buff += "   0.3-0.5 : ok\n"
    buff += "   0.5-1.0 : bad\n\n"
    buff += "\t\tHellinger distance (Scoring function)\n"


    if exclude_outliers:
        buff += "\n\tNB: values over 0.5 have been excluded from the above summary value\n\n"
    else:
        buff += '\n'

    overall_scores = []
    for interaction_type in h_score_dict.keys():
        buff += f" {interaction_type} \n"
        for atom_group, h_score in h_score_dict[interaction_type].items():
            score = score_dict[interaction_type][atom_group]
            if exclude_outliers and h_score >= 0.5: # arbitrary cutoff for now
                buff += f"\t{atom_group:20s}: {h_score:.2f} ({score:.2f})(excluded)\n"
            else:
                buff += f"\t{atom_group:20s}: {h_score:.2f} ({score:.2f})\n"
                overall_scores.append(score)
        buff += '\n'

    printable = buff.format(mean=np.array(overall_scores).mean(),
                            std=np.array(overall_scores).std())

    print(printable)
    with open('report_interactions.out', 'w') as fout:
        fout.writelines(printable)


def report_distances(score_matrix, molname, atom_names):
    """
    Print out a report of the distance score matrix.

    Parameters
    ----------
    score_matrix : np.ndarray
        Score matrix for pairwise distances.
    molname : str
        Name of the molecule.
    atom_names : list of str
        List of atom names corresponding to the score matrix.
    """
    score_matrix_report = np.vstack([atom_names, score_matrix])
    score_matrix_report = np.column_stack([[''] + atom_names, score_matrix_report])
    buff = ''
    buff += f" [ Distance Distribution Report for {molname} ]\n "
    buff += f" Overall Score : {{mean:.2f}} ± {{std:.2f}}\n\n"
    buff += f"   Max Score : {{max:.2f}}\n\n"
    buff += " Score guide:\n"
    buff += "   0.0-0.3 : good\n"
    buff += "   0.3-0.5 : ok\n"
    buff += "   0.5-1.0 : bad\n"
    buff += "\n   Score Matrix:\n"
    buff += " 0 - identical, 1 - no overlap\n\n"

    for i, row in enumerate(score_matrix_report):
        if i == 0:
            buff += "" + " ".join(f"{name:>5}" for name in row) + "\n" # Header row
        else:
            buff += f"{row[0]:>5} " + " ".join(f"{float(score):>5.2f}" for score in row[1:]) + "\n" # First element is the atom name, rest are scores

    off_diag = score_matrix[~np.eye(score_matrix.shape[0], dtype=bool)] # Exclude diagonal (0) for mean and std calculation
    printable = buff.format(molname=molname,
                      mean=np.mean(off_diag),
                      std=np.std(off_diag),
                      max=np.max(score_matrix))
    print(printable)
    with open('report_distances.out', 'w') as fout:
        fout.writelines(printable)

def __main__():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,)
    parser.add_argument('-f', type=str, dest="trajfile", help="simulated trajectory file")
    parser.add_argument('-s', type=str, dest="tprfile", help="simulated tpr file", default=None)
    parser.add_argument('-i', type=str, dest="itp_files", help="itp file", nargs='*')
    parser.add_argument('-d', type=str, dest='reference',
                        help="Path to directory with reference distributions")
    parser.add_argument('-plots', default=None, const=".", nargs="?",
                        dest="plots",
                        help="Make plots comparing distributions. Optionally provide a path (default: current dir)")
    parser.add_argument('-outliers', default=False, action='store_true', dest='exclude_outliers',
                        help='exclude outliers from overall score')
    parser.add_argument('-plot-data', default=False, action='store_true', dest="plot_data",
                        help='save data for making plots as single pickle file')
    parser.add_argument('-score-weight', dest='hellinger_weight', type=float, default=0.7,
                        help='weight of the Hellinger distance in the distance score')
    parser.add_argument('-include-constraints', default=False, action='store_true', dest='include_constraints',
                        help='fully include constrained distances in the distance score score calculation')
    parser.add_argument('-dists', default=False, action='store_true',
                        dest="distribution_data",
                        help="Save text files with time series and distribution data for interactions")

    args = parser.parse_args()

    distribution_files = glob(f'{args.reference}/*distr.dat')

    # load trajectory
    if args.tprfile:
        u = mda.Universe(args.tprfile, args.trajfile, in_memory=True)
    else:
        u = mda.Universe(args.trajfile, in_memory=True)

    plot_data = defaultdict(dict)
    # if itp file is provided use it
    if args.itp_files:
        ff = vermouth.forcefield.ForceField("dummy")
        for file_handle in args.itp_files:
            with open(file_handle) as _file:
                lines = _file.readlines()
            read_itp(lines, ff)

        interaction_mapper = ITPInteractionMapper(u, ff.blocks.values(), ff.blocks.keys())
        
        # evaluation of interactions
        h_score_dict = {'bonds': {},
                        'angles': {},
                        'dihedrals': {}}
        score_dict = {'bonds': {},
                        'angles': {},
                        'dihedrals': {}}
        # loop over molecules
        for molname, block in ff.blocks.items():
            interaction_groups, _, _ = interaction_mapper.get_interactions_group(molname)
            for inter_type in ['bonds', 'angles', 'dihedrals']:
                for group_name, pair_idxs in interaction_groups[inter_type].items():
                    distr, _ = interaction_distribution(u, inter_type, pair_idxs, save=args.distribution_data)
                    # calculate simulation distribution
                    probs = distr.T[1]
                    # read in reference distribution
                    try:
                        reference_data = np.loadtxt([i for i in distribution_files if group_name in i and inter_type in i][0])
                    except IndexError:
                        print(f"{group_name} file not found!")
                        continue
                    # calculate hellinger distance between simulated and reference distributions
                    h_score = hellinger(probs/probs.sum(), reference_data.T[1] / reference_data.T[1].sum())
                    h_score_dict[inter_type][group_name] = h_score

                    score = calc_score(reference_data.T[1]/ reference_data.T[1].sum(), probs/probs.sum(), [args.hellinger_weight, 1-args.hellinger_weight], inter_type)
                    score_dict[inter_type][group_name] = score

                    plot_data[inter_type][group_name] = {"x": reference_data.T[0],
                                                         "Reference": reference_data.T[1],
                                                         'Simulated': probs}
        if args.plots:
            make_distribution_plot(plot_data, args.plot_data, name=f'{args.plots}/distribution_comparison')
        report_interactions(h_score_dict, score_dict, args.exclude_outliers)
        
        # evaluation of distances
        for molname, block in ff.blocks.items():
            score_m, plot_data = score_matrix(molname, 
                                   block, 
                                   u, 
                                   distribution_files,
                                   args.hellinger_weight,
                                   args.include_constraints)

            atom_names = [f'{resid}_{name}' for (_, name), (_, resid) in zip(block.nodes(data='atomname'), block.nodes(data='resid'))]

            if args.plots:
                make_matrix_plot(score_m, atom_names, name=f'{args.plots}/score_matrix_{molname}')
                make_distances_distribution_plot(plot_data, atom_names, name=f'{args.plots}/distance_distributions_{molname}')
            report_distances(score_m, molname, atom_names)

__main__()
